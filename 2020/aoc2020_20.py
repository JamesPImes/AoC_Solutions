
import aoctools
import math


class Grid:
    def __init__(self, raw):
        self.tiles = {}

        self.parse_tiles(raw)
        self.w = self.h = int(math.sqrt(len(self.tiles)))
        self.layout = None
        self.corners = []
        self.img = None

        # Per puzzle instructions, we should have only a square number
        # of tiles; just make sure we didn't lop off something...
        assert self.w * self.h == len(self.tiles)

    def find_matches(self):
        """
        Find and store the names of every other tile with a side that
        can match to any side of each tile. (Stored as a list for each
        tile in `a_tile.possible_matches`). Return the corner tiles
        (i.e. tiles that contain exactly 2 possible matches), which are
        also stored to the Grid as a list in instance var `.corners`.
        """
        # If a tile has only two sides that match, it is definitely a
        # corner piece -- ASSUMING a couple things: (a) that there are
        # ANY pieces in our dataset with 2-max matches; and (b) that
        # there are no pieces that do not fit in our puzzle.
        known_corner_pieces = []
        for name1, tile1 in self.tiles.items():
            tile1.find_matches(available_tiles=self.tiles)
            if len(tile1.possible_matches) == 2:
                known_corner_pieces.append(name1)
        self.corners = known_corner_pieces.copy()
        return known_corner_pieces

    def print_row(self, row, include_names=True):
        """
        Quality of life dev tool for visualizing the current state of a
        row.
        """
        if len(row) == 0:
            return
        t_height = len(self.tiles[row[0]].face)
        if include_names:
            print(row)
        for y in range(t_height):
            s = ''
            for tn in row:
                s = s + f"{''.join([x + ' ' for x in self.tiles[tn].face[y]])}   "
            print(s)

    def clean_assemble(self, rough: list):
        """
        Conjoin the tiles (as laid out in the grid `rough`), per puzzle
        rules. Store the results as `self.img`
        :param rough: The `constructor` variable generated by
        `assemble_tiles`.
        :return:
        """

        s = ''
        tile_height = len(self.tiles[rough[0][0]].face)

        img = ''
        for row in rough:  # break down to list of rows
            row_s = ''
            for y in range(1, tile_height - 1):  # exclude first/last columns
                for tn in row:  # break each row down into tile names
                    tile = self.tiles[tn]
                    scan_line = tile.face[y].copy()[1:-1]
                    row_s = row_s + ''.join(scan_line)
                row_s = row_s + '\n'
            img = img + row_s
        img = img.strip()
        self.img = img
        return img

    def assemble_tiles(self):
        """
        Assemble the raw, unsorted tiles into the grid, rotating /
        flipping them as necessary, until all adjoining sides mirror
        one another. Save the resulting grid of tile names as instance
        variable `.layout` (in case it is needed later), and flatten it
        into a single string (trimming the outermost rows/columns of
        each tile, per puzzle instructions).
        :return: A string of the trimmed, flattened, joined-up tiles.
        """

        WIDTH = self.w
        HEIGHT = self.h

        def first_rc(
                start_tile, end_tiles: list, used_tiles=None, rlen=None,
                make_col=False):
            """
            Make the FIRST ROW / COLUMN --
            Recursively generate rows (or columns with `make_col=True`)
            until we make one that ends with one of the possible
            `end_tiles` (i.e. another corner tile).
            """
            frow = [start_tile]

            if rlen is None and not make_col:
                rlen = WIDTH
            elif rlen is None and make_col:
                rlen = HEIGHT

            direction = 'E'
            if make_col:
                direction = 'S'

            if len(frow) == rlen:
                if start_tile not in end_tiles:
                    return False
                return frow

            if used_tiles is None:
                used_tiles = []

            st = self.tiles[start_tile]

            for pm in st.possible_matches:
                if pm in used_tiles:
                    continue
                attach = st.match_sides(
                    t2=self.tiles[pm], t1_side=direction)
                if not attach:
                    continue
                result = first_rc(
                    pm, end_tiles, used_tiles=used_tiles + [start_tile],
                    rlen=rlen - 1, make_col=make_col)
                if result:
                    frow.extend(result)
                    return frow
            return False

        def new_row(last_row, first_tile, used_tiles, rlen=WIDTH):
            """
            Construct another row (not including the first).
            """
            row = [first_tile]

            # TODO: Debug -- This loop SHOULD be redundant / unnecessary:
            for i in range(len(last_row)):
                if i == len(last_row) - 1:
                    break
                self.tiles[last_row[i]].match_sides(
                    self.tiles[last_row[i + 1]], t1_side='E')

            while len(row) < rlen:
                i = len(row)
                up = self.tiles[last_row[i]]
                left = self.tiles[row[-1]]

                # The next tile must match both to the left and up.
                next_tile = set(up.possible_matches)
                next_tile = next_tile.intersection(set(left.possible_matches))
                next_tile = next_tile - set(used_tiles)

                # Sanity check. Ensure there is only one possible tile.
                assert len(next_tile) == 1

                next_tile = next_tile.pop()
                nt = self.tiles[next_tile]

                matched_left = left.match_sides(t2=nt, t1_side='E')

                # Once locked in on left/right, disallow further transformations
                matched_up = up.match_sides(nt, t1_side='S', xforms=[''])

                # Sanity check. Ensure this tile matched both left and up.
                assert matched_left and matched_up

                row.append(nt.name)

            return row

        # `.find_matches()` causes every tile to find its possible
        # matches, and it returns a list of apparent corner pieces
        # (tiles with only 2 matches).
        corners = self.find_matches()
        if len(corners) != 4:
            print('FAIL: Cannot use this algorithm for this dataset.')
            return None

        used_tiles = []

        first_tile = corners.pop()
        ft = self.tiles[first_tile]

        # Orient our first tile so that rows -> east, and columns -> south
        xforms = Tile.XFORMS.copy()
        pms = ft.possible_matches
        victory = False
        for xf in xforms:
            ft.transform(xf)
            for _ in range(2):
                e_match = ft.match_sides(t2=self.tiles[pms[0]], t1_side='E')
                s_match = ft.match_sides(t2=self.tiles[pms[1]], t1_side='S')
                victory = e_match and s_match
                if victory: break
                else: pms.reverse()
            if victory: break

        f_row = first_rc(first_tile, end_tiles=corners)

        # Sanity check. f_row should not be None.
        assert f_row

        other_corners = [nm for nm in corners if nm not in f_row]

        f_col = first_rc(first_tile, end_tiles=other_corners, make_col=True)

        # Sanity check. f_row and f_col should both exist.
        assert f_row and f_col

        # Now that we have our first row and the first tile of each
        # subsequent row, construct the rest of the rows.
        used_tiles.extend(f_row)
        constructor = [f_row]
        while len(constructor) < self.h:
            row = new_row(
                last_row=constructor[-1],
                first_tile=f_col[len(constructor)],
                used_tiles=used_tiles)
            used_tiles.extend(row)
            constructor.append(row)

        self.layout = constructor
        img = self.clean_assemble(constructor)
        return img

    def parse_tiles(self, raw):
        tiles_raw = raw.split('\n\n')
        for tile in tiles_raw:
            nt = Tile(tile)
            self.tiles[nt.name] = nt

        return self.tiles

    def rotate_clean(self, clean):
        """
        :param clean: An list of rows, already ordered in such a way
        that they fit together. (Represents a semi-grid, construction in
        progress.)
        :return: The clean semi-grid, its contents having been rotated.
        """
        clean.reverse()
        for row in clean:
            self.rotate_row(row)
        return clean

    def rotate_row(self, row):
        """
        :param row: A list of tile names.
        :return: The row, rotated 180 degrees.
        """
        row.reverse()
        for tile_name in row:
            self.tiles[tile_name].rotate(2)
        return row

    def flip_row_ew(self, row):
        """
        :param row: A list of tile names.
        :return: The row, flipped East/West.
        """
        row.reverse()
        for tile_name in row:
            self.tiles[tile_name].flip_ew()
        return row

    def flip_row_ns(self, row):
        """
        :param row: A list of tile names.
        :return: The row, flipped North/South.
        """
        for tile_name in row:
            self.tiles[tile_name].flip_ns()
        return row


class Tile:
    # All basic rotations, including no rotation ('R1' -> rotate 1)
    XFORMS = ['', 'R1', 'R1', 'R1']

    # Up/Down flip, then all sides ('NS' -> flip_ns)
    XFORMS.extend(['R1,NS', 'R1', 'R1', 'R1'])

    MONSTER = None

    def __init__(self, raw_tile: str):
        name, face = raw_tile.split(':\n')
        self.name = name.replace('Tile ', '')

        # Tile face represented as nested list; `face[y][x]` for (x, y) value
        self.face = [[x for x in row] for row in face.split('\n')]

        self.w = len(self.face[0])
        self.h = len(self.face)

        self.cached_xforms = None  # Did not end up needing cache for our data
        self.possible_matches = []

        if Tile.MONSTER is None:
            self.compile_monsters()

    @property
    def side_W(self):
        return [self.face[y][0] for y in range(self.h)]

    @property
    def side_E(self):
        return [self.face[y][self.w - 1] for y in range(self.h)]

    @property
    def side_N(self):
        return [self.face[0][x] for x in range(self.w)]

    @property
    def side_S(self):
        return [self.face[self.h - 1][x] for x in range(self.w)]

    def rotate(self, n=1):
        """Rotate the face 90 degrees clockwise `n` times."""
        for _ in range(n % 4):
            rot = []
            for x in range(self.w):
                rot.append([])
                for y in range(self.h - 1, -1, -1):
                    rot[-1].append(self.face[y][x])

            self.face = rot

    def flip_ew(self):
        """Flip the face left/right."""
        for row in self.face:
            row.reverse()

    def flip_ns(self):
        """Flip the face up/down."""
        self.face.reverse()

    def find_matches(self, available_tiles: dict):
        """
        Find all possible matches (of any side to any other side) within
        the consideration set `available_tiles`.
        """
        for side in ['E', 'S', 'W', 'N']:
            for name, tile in available_tiles.items():
                if name == self.name or name in self.possible_matches:
                    continue
                success_check = self.match_sides(tile, t1_side=side)
                if success_check is not None:
                    self.possible_matches.append(name)
                    tile.possible_matches.append(self.name)

    def match_sides(self, t2, t1_side=None, xforms=None):
        """
        :param t2: A tile to compare to the sides of `self`.
        :param t1_side: The name of the side of our tile to which to try
        to attach `t2` -- either 'W', 'N', 'E', or 'S'.
        :param xforms: The specific transformations (in order) to
        consider for `t2`. If not specified, will use the
        transformations that it has cached; and if there are none there,
        will use all transformations.
        :return: Returns the name of the side of the `t2` Tile that
        connects to our Tile ('W', 'N', 'E', or 'S'). Returns None if
        there was no appropriate match.
        """

        # Which side of `t1` (i.e. self) matches to which side of `t2`
        matchups = {
            'W': 'E',
            'E': 'W',
            'N': 'S',
            'S': 'N'
        }

        # Side name -> the function to get that side value
        get_side = {
            'W': lambda x: x.side_W,
            'E': lambda x: x.side_E,
            'N': lambda x: x.side_N,
            'S': lambda x: x.side_S
        }

        if t1_side is None:
            t1_side = 'E'

        name1 = t1_side
        t1_side = get_side[name1](self)
        name2 = matchups[name1]

        if xforms is None:
            # All possible transformations
            xforms = Tile.XFORMS.copy()
        # elif xforms is None and t2.cached_xforms is not None:
        #     tforms = t2.cached_xforms

        while len(xforms) > 0:
            xf = xforms.pop(0)
            t2.transform(xf)
            t2_side = get_side[name2](t2)

            if t1_side == t2_side:
                # Cache our unused transformations with `t2` and
                # return the matched side. (We'll use the remaining
                # transformations on `t2` if it needs to be detached
                # and retried later on.)
                t2.cached_xforms = xforms

                return name2

        return None

    def transform(self, xforms=''):
        """
        Enact the specified transformations (`xforms`) on this tile.
        :param xforms: A string of transformations ('R1', 'NS', or 'EW',
        or any combination thereof, allowing multiples), separated by
        comma.
        :return: None (transformations are done in situ)
        """
        for cmd in xforms.split(','):
            if cmd == 'R1':
                self.rotate()
            elif cmd == 'NS':
                self.flip_ns()
            elif cmd == 'EW':
                self.flip_ew()

    def print(self):
        """
        Quality of life dev tool for visualizing the current state of a
        tile.
        """
        fc = self.face
        w = self.w
        h = self.h
        print('\n'.join([''.join([fc[y][x] for x in range(w)]) for y in range(h)]))

    def find_monsters(self):
        """
        Find and blank out all monsters in our waters.
        """

        def blank_out_monster(x_j, y_i):
            for x, y in Tile.MONSTER:
                self.face[y_i + y][x_j + x] = '0'

        x_list = [x for x, y in Tile.MONSTER]
        y_list = [y for x, y in Tile.MONSTER]

        mn_x = min(x_list)
        mx_x = max(x_list)
        mn_y = min(y_list)
        mx_y = max(y_list)
        px_needed = len(Tile.MONSTER)

        assert mn_x == 0 and mn_y == 0

        i = 0
        monster_count = 0
        while i < self.h - mx_y:
            j = 0
            while j < self.w - mx_x:
                px_spotted = 0
                for x, y in Tile.MONSTER:
                    if self.face[i + y][j + x] == '#':
                        px_spotted += 1
                if px_spotted == px_needed:
                    monster_count += 1
                    blank_out_monster(j, i)
                j += 1
            i += 1
        return monster_count

    @classmethod
    def compile_monsters(cls):
        '''
        Compile the sea monsters decoder, per the pattern specified in
        Part 2 rules.
        '''

        monster = (
            "_                  # _\n"
            "_#    ##    ##    ###_\n"
            "_ #  #  #  #  #  #   _"
        )

        scanlines = [l.strip('_') for l in monster.split('\n')]

        decoder = [
            (j, i)
            for i in range(len(scanlines))
            for j in range(len(scanlines[0]))
            if scanlines[i][j] == '#'
        ]
        Tile.MONSTER = decoder

    def count_choppy_water(self):
        tot = 0
        for row in self.face:
            for char in row:
                tot += 1 if char == '#' else 0
        return tot


def part1(raw):
    grid = Grid(raw)
    corners = grid.find_matches()

    # For part 1, exploit the fact that our dataset does not contain any
    # corner tiles that have more than 2 possible matches among the
    # other tiles. Answers the question without solving the underlying
    # problem, though. (See Part 2 for the actual solve.)
    assert len(corners) == 4
    prod = 1
    for c in corners:
        prod *= int(c)
    return prod


def part2(raw):
    grid = Grid(raw)
    clean_img = grid.assemble_tiles()
    ci = Tile('Tile img:\n' + clean_img)

    # Replace all 'monster' pixels with '0', flipping/rotating as needed
    # until we start to identify them.
    for xf in Tile.XFORMS:
        ci.transform(xf)
        if ci.find_monsters() > 0:
            break

    return ci.count_choppy_water()


puz_in = aoctools.puzzle_input(2020, 20)
test_data = '''Tile 2311:
..##.#..#.
##..#.....
#...##..#.
####.#...#
##.##.###.
##...#.###
.#.#.#..##
..#....#..
###...#.#.
..###..###

Tile 1951:
#.##...##.
#.####...#
.....#..##
#...######
.##.#....#
.###.#####
###.##.##.
.###....#.
..#.#..#.#
#...##.#..

Tile 1171:
####...##.
#..##.#..#
##.#..#.#.
.###.####.
..###.####
.##....##.
.#...####.
#.##.####.
####..#...
.....##...

Tile 1427:
###.##.#..
.#..#.##..
.#.##.#..#
#.#.#.##.#
....#...##
...##..##.
...#.#####
.#.####.#.
..#..###.#
..##.#..#.

Tile 1489:
##.#.#....
..##...#..
.##..##...
..#...#...
#####...#.
#..#.#.#.#
...#.#.#..
##.#...##.
..##.##.##
###.##.#..

Tile 2473:
#....####.
#..#.##...
#.##..#...
######.#.#
.#...#.#.#
.#########
.###.#..#.
########.#
##...##.#.
..###.#.#.

Tile 2971:
..#.#....#
#...###...
#.#.###...
##.##..#..
.#####..##
.#..####.#
#..#.#..#.
..####.###
..#.#.###.
...#.#.#.#

Tile 2729:
...#.#.#.#
####.#....
..#.#.....
....#..#.#
.##..##.#.
.#.####...
####.#.#..
##.####...
##..#.##..
#.##...##.

Tile 3079:
#.#.#####.
.#..######
..#.......
######....
####.#..#.
.#...#.##.
#.#####.##
..#.###...
..#.......
..#.###...'''

aoctools.test(1, part1, test_data, 20899048083289)
aoctools.test(2, part2, test_data, 273)

aoctools.submit(1, part1, puz_in)
aoctools.submit(2, part2, puz_in)
